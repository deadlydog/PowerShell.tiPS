name: build

on:
  pull_request:
    branches: main

  # Allows you to run this workflow manually from the Actions tab.
  workflow_dispatch:

  # Allows the deployment workflow to call this workflow.
  workflow_call:
    inputs:
      versionNumber:
        description: 'The version number to use for the module. This should be in the format of "Major.Minor.Patch". e.g. "1.0.0". Future builds will increment from this version number. This input is optional. If not provided, the previous version numbers Patch will be incremented.'
        required: false
        type: string
        default: ''
    # Outputs required by the deployment workflow.
    outputs:
      powerShellModuleName:
        description: 'The name of the PowerShell module being built.'
        value: ${{ jobs.build-and-test.outputs.powerShellModuleName }}
      prereleaseModuleArtifactName:
        description: 'The name of the prerelease module artifact created by the build.'
        value: ${{ jobs.build-and-test.outputs.prereleaseModuleArtifactName }}
      stableModuleArtifactName:
        description: 'The name of the stable module artifact created by the build.'
        value: ${{ jobs.build-and-test.outputs.stableModuleArtifactName }}
      deployFilesArtifactName:
        description: 'The name of the deploy files artifact created by the build.'
        value: ${{ jobs.build-and-test.outputs.deployFilesArtifactName }}

env:
  powerShellModuleName: 'tiPS'
  powerShellModuleDirectoryPath: './src/tiPS'
  deployFilesDirectoryPath: './deploy'
  prereleaseModuleArtifactName: 'PrereleaseModuleArtifact'
  prereleaseModuleArtifactDirectoryPath: './artifacts/Prerelease'
  stableModuleArtifactName: 'StableModuleArtifact'
  stableModuleArtifactDirectoryPath: './artifacts/Stable'
  deployFilesArtifactName: 'DeployFilesArtifact'
  deployFilesArtifactDirectoryPath: './artifacts/deploy'

jobs:
  build-and-test:
    runs-on: windows-latest # Use Windows agent to ensure dotnet.exe is available to build C# assemblies.
    outputs:
      powerShellModuleName: ${{ env.powerShellModuleName }}
      prereleaseModuleArtifactName: ${{ env.prereleaseModuleArtifactName }}
      stableModuleArtifactName: ${{ env.stableModuleArtifactName }}
      deployFilesArtifactName: ${{ env.deployFilesArtifactName }}
    steps:
      - name: Checkout the repo source code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Fetch all history so that GitVersion can determine the version number.

      - name: Run spellcheck
        uses: streetsidesoftware/cspell-action@v5

      - name: Display PowerShell version being used
        shell: pwsh
        run: $PSVersionTable

      - name: Build the C# assemblies
        shell: pwsh
        run: ./build/Build-CSharpAssemblies.ps1 -Force

      - name: Generate PowerShellTips.json file
        shell: pwsh
        run: ./build/Convert-PowerShellTipFilesToJsonFile.ps1

      - name: Run PowerShell linter with PSScriptAnalyzer
        shell: pwsh
        run: Invoke-ScriptAnalyzer -Path . -Recurse -EnableExit

      - name: Run Pester tests and generate code coverage report
        shell: pwsh
        run: |
          Write-Output "Pester version being used:"
          Import-Module -Name Pester
          Get-Module -Name Pester

          Write-Output "Running all Pester tests in the repo:"
          $pesterConfig = New-PesterConfiguration @{
            Output = @{ Verbosity = 'Detailed' }
            Run = @{ Throw = $true }
            TestResult = @{
              Enabled = $true
              OutputPath = 'test-results-nunit.xml'
            }
            CodeCoverage = @{
              Enabled = $true
              OutputPath = 'code-coverage-jacoco.xml'
              Path = 'src/' # Only include code coverage for the module's source code, not build or deployment scripts.
            }
          }
          Invoke-Pester -Configuration $pesterConfig

      - name: Add code coverage report to PR
        # Adding the code coverage report is not supported for manual workflow runs.
        if: github.event_name != 'workflow_dispatch'
        uses: madrapps/jacoco-report@v1.6.1
        with:
          paths: code-coverage-jacoco.xml
          token: ${{ secrets.GITHUB_TOKEN }}
          min-coverage-overall: 60
          min-coverage-changed-files: 60

      - name: Build the concatenated psm1 file
        shell: pwsh
        run: ./build/Build-Psm1File.ps1 -DeleteSourceFilesAfterImport

      - name: Run Pester tests again to ensure the concatenated psm1 file works as expected
        shell: pwsh
        run: |
          Write-Output "Pester version being used:"
          Import-Module -Name Pester
          Get-Module -Name Pester

          Write-Output "Running all Pester tests in the repo:"
          $pesterConfig = New-PesterConfiguration @{
            Output = @{ Verbosity = 'Detailed' }
            Run = @{ Throw = $true }
            TestResult = @{ Enabled = $false }
            CodeCoverage = @{ Enabled = $false }
          }
          Invoke-Pester -Configuration $pesterConfig

      - name: Install GitVersion
        uses: gittools/actions/gitversion/setup@v0
        with:
          versionSpec: '5.x'

      - name: Get git metadata used for new version number
        id: git-version
        uses: gittools/actions/gitversion/execute@v0

      - name: Determine the new version number
        shell: pwsh
        run: |
          Write-Output "Getting new version numbers to use."
          [string] $newVersionNumber = '${{ steps.git-version.outputs.majorMinorPatch }}'
          [string] $prereleaseLabel = '${{ steps.git-version.outputs.preReleaseTag }}'

          # The preReleaseTag is empty when building the default branch, so manually create a prerelease version number if needed.
          if ([string]::IsNullOrWhiteSpace($prereleaseLabel)) {
            [string] $dateTime = (Get-Date -Format 'yyyyMMddTHHmmss')
            $prereleaseLabel = 'ci' + $dateTime + 'SHA' + '${{ steps.git-version.outputs.shortSha }}'
          }
          # PowerShell prerelease labels can only contain the characters 'a-zA-Z0-9', so sanitize it if needed.
          $newVersionNumberPrereleaseLabel = $prereleaseLabel -replace [^a-zA-Z0-9], ''

          Write-Output "Setting new environment variables 'NewVersionNumberMajorMinorPatch=$newVersionNumber' and 'NewVersionNumberPrereleaseLabel=$ciVersionTag'."
          "NewVersionNumberMajorMinorPatch=$newVersionNumber" | Out-File -FilePath $Env:GITHUB_ENV -Encoding utf8 -Append
          "NewVersionNumberPrereleaseLabel=$newVersionNumberPrereleaseLabel" | Out-File -FilePath $Env:GITHUB_ENV -Encoding utf8 -Append

      - name: Create Stable and Prerelease module artifacts
        shell: pwsh
        run: |
          Write-Output "Reading in environment variables."
          [string] $moduleName = $Env:powerShellModuleName
          [string] $moduleDirectoryPath = $Env:powerShellModuleDirectoryPath
          [string] $moduleManifestFileName = $moduleName + '.psd1'
          [string] $prereleaseArtifactModuleDirectoryPath = Join-Path -Path $Env:prereleaseModuleArtifactDirectoryPath -ChildPath $moduleName
          [string] $stableArtifactModuleDirectoryPath = Join-Path -Path $Env:stableModuleArtifactDirectoryPath -ChildPath $moduleName
          [string] $versionNumber = $Env:NewVersionNumberMajorMinorPatch
          [string] $prereleaseVersionNumberLabel = $Env:NewVersionNumberPrereleaseLabel

          Write-Output "Copying the module files to the Prerelease artifact directory '$prereleaseArtifactModuleDirectoryPath'."
          Copy-Item -Path $moduleDirectoryPath -Destination $prereleaseArtifactModuleDirectoryPath -Exclude '*.Tests.ps1' -Recurse -Force

          Write-Output "Copying the module files to the Stable artifact directory '$stableArtifactModuleDirectoryPath'."
          Copy-Item -Path $moduleDirectoryPath -Destination $stableArtifactModuleDirectoryPath -Exclude '*.Tests.ps1' -Recurse -Force

          Write-Output "Determining what the module manifest file paths are."
          [string] $manifestFilePath = Join-Path -Path $moduleDirectoryPath -ChildPath $moduleManifestFileName
          [string] $prereleaseManifestFilePath = Join-Path -Path $prereleaseArtifactModuleDirectoryPath -ChildPath $moduleManifestFileName
          [string] $stableManifestFilePath = Join-Path -Path $stableArtifactModuleDirectoryPath -ChildPath $moduleManifestFileName

          Write-Output "Updating the prerelease manifest's version number to '$versionNumber-$prereleaseVersionNumberLabel'."
          Update-ModuleManifest -Path $prereleaseManifestFilePath -ModuleVersion $versionNumber -Prerelease $prereleaseVersionNumberLabel

          Write-Output "Updating the stable manifest's version number to '$versionNumber'."
          Update-ModuleManifest -Path $stableManifestFilePath -ModuleVersion $versionNumber

          Write-Output "Testing the Prerelease manifest file '$prereleaseManifestFilePath' to ensure it is valid."
          Test-ModuleManifest -Path $prereleaseManifestFilePath

          Write-Output "Testing the Stable manifest file '$stableManifestFilePath' to ensure it is valid."
          Test-ModuleManifest -Path $stableManifestFilePath

      - name: Create deploy files artifact
        shell: pwsh
        run: |
          [string] $deployFilesDirectoryPath = $Env:deployFilesDirectoryPath
          [string] $deployFilesArtifactDirectoryPath = $Env:deployFilesArtifactDirectoryPath

          Write-Output "Copying the deployment files '$deployFilesDirectoryPath' to the deployment artifact directory '$deployFilesArtifactDirectoryPath'."
          Copy-Item -Path $deployFilesDirectoryPath -Destination $deployFilesArtifactDirectoryPath -Recurse -Force

      - name: Update CI version tag and set new version tag
        # Only run this step if we are doing a push (not a PR) to the default branch (e.g. main).
        if: github.event_name != 'pull_request' && github.ref == format('refs/heads/{0}', github.event.repository.default_branch)
        shell: pwsh
        run: |
          [string] $newVersionNumber = $Env:NewVersionNumberMajorMinorPatch
          [string] $newVersionTag = "v$newVersionNumber"

          # To avoid a 403 error on 'git push', ensure you have granted your GitHub Actions workflow read/write permission.
          # In your GitHub repo: Settings > Actions > General > Workflow permissions > Read and write permissions
          # https://docs.github.com/en/repositories/managing-your-repositorys-settings-and-features/enabling-features-for-your-repository/managing-github-actions-settings-for-a-repository#configuring-the-default-github_token-permissions

          Write-Output "Tagging commit with new version tag '$newVersionTag'."
          & git tag $newVersionTag
          & git push origin $newVersionTag

      - name: Upload prerelease module artifact
        uses: actions/upload-artifact@v3
        with:
          name: ${{ env.prereleaseModuleArtifactName }}
          path: ${{ env.prereleaseModuleArtifactDirectoryPath }}

      - name: Upload stable module artifact
        uses: actions/upload-artifact@v3
        with:
          name: ${{ env.stableModuleArtifactName }}
          path: ${{ env.stableModuleArtifactDirectoryPath }}

      - name: Upload deploy files artifact
        uses: actions/upload-artifact@v3
        with:
          name: ${{ env.deployFilesArtifactName }}
          path: ${{ env.deployFilesArtifactDirectoryPath }}
